# Упражнение
Да се напише клас String за работа със символни низове.
Очаквани методи:

- За капацитет:
    - size - Return length of string (public member function )
    - at - Get character in string (public member function )
    - back - Access last character (public member function )
    - front - Access first character (public member function )
- За модифициране
    - operator+= - Append to string (public member function )
    - append - Append to string (public member function )
    - push_back - Append character to string (public member function )
    - insert - Insert into string (public member function )
    - erase - Erase characters from string (public member function )
    - replace - Replace portion of string (public member function )
    - swap - Swap string values (public member function )
    - pop_back - Delete last character (public member function )
- Операции:
    - c_str - Get C string equivalent (public member function )
    - substr - Generate substring (public member function )
    - operator+ - Concatenate strings (function )
    - all relational operators - Relational operators for string (function )
    - operator>> - Extract string from stream (function )
    - operator<< - Insert string into stream (function )

**Забележка:** помислете как може класът да се реализира максимално оптимално.

# Задачи

##  Задача 1

А) За улеснение, ще считаме, че всеки регистрационен номер на превозно средство е поредица от символи, подредени както следва:
един или два символа от латинската азбука, които указват населено място;
четири цифри;
два символа от латинската азбука.

Например C1234AB, XY1111YX са валидни регистрационни номера, а 111145, ABC34DEF, ABCDEF и C11D не са.
 
Реализирайте клас `Registration`, който представя регистрационен номер. Вътрешно класът да пази информацията като низ от тип `char[9]`, който съдържа символите на номера. Класът да има следния интерфейс:

Класът НЕ ТРЯБВА да има конструктор по подразбиране.

`Registration(const char* str)` - Конструктор, който зарежда в обекта регистрационния номер записан в str. Ако str не съдържа валиден регистрационен номер, хвърля изключение от тип `std::exception`.

`Registration& operator=(const char* str)` - Зарежда в обекта регистрационния номер записан в str. Ако str не съдържа валиден регистрационен номер, хвърля изключение от тип std::exception.

`bool operator==(const Registration& rhs) const` - Проверява дали два регистрационни номера са еднакви.

`const char* toString() const` - Връща регистрационния номер.

Б) Реализирайте клас `Vehicle` (превозно средство). То трябва да има следните публични член-данни:

`regnum` – регистрационен номер, константа от тип `Registration`.

`description` – описание,  низ с произволна дължина

Класът да има следния интерфейс:

Класът ДА НЯМА конструктор по подразбиране

`Vehicle(const char* regnum, const char* description)`

В) Реализирайте клас `VehicleList`, който представя списък от коли. 

Списъкът има капацитет, който се посочва при неговото създаване. Капацитетът може да бъде произволно голям. Той се подава само веднъж при създаването на списъка и после не може да се променя. 

В списъка не трябва да може да се съдържат две превозни средства с еднакви номера.

Подсказка:  
Помислете за най-подходящия тип данни на масива - <тип> * vehicles

Обърнете внимание, че `Vehicle` обектите нямат default constructor. Преценете как да адресирате този проблем (например използвайте масив от указатели).

Класът да има следния интерфейс:

`VehicleList(size_t capacity) ` - Създава списък, който може да съдържа най-много capacity на брой превозни средства. 


Всички функции от rule of 3 (по желание: всички от rule of 5).  

VehicleList притежава колите съхранени в него и трябва да ги почиства в деструктора си. 

При копиране на списък от коли, новото копие трябва да създаде за себе си НОВИ обекти от тип Vehicle; то не трябва да сочи към превозните средства на оригинала. Копието трябва да бъде със същия капацитет като оригинала.


`void insert(const char* regnum, const char* description)` - Добавя превозното средство с регистрационен номер `regnum` и описание `description` в списъка. Ако операцията не успее (например няма повече място, въведен е невалиден регистрационен номер, такъв регистрационен номер вече се съдържа в списъка), да се хвърля изключение от тип `std::exception`.
(Вместо изключение можете да направите методът булев и да използвате assert в дебъг режим.)


`const Vehicle& at(size_t index) const` - Дава достъп до елемента, който се  намира на позиция `index`. Ако такъв няма, да се хвърля изключение от тип std::exception.


`const Vehicle& operator[](size_t pos) const ` - Реализира достъп до елемента, който се намира на позиция pos. Функцията да не прави проверка за коректност дали pos е валидна позиция. (В debug режим assert-вайте дали pos е валидна позиция).


`bool empty() const` - Проверява дали списъка е празен (т.е. в него не е било добавено нито едно добавено превозно средство).
`std::size_t capacity() const ` - Връща капацитета на списъка.


`std::size_t size() const` - Връща брой превозни средства добавени в списъка.


`const Vehicle* find(const Registration& regnum) const` - Намира и връща превозното средство с регистрационен номер regnum. Ако такова няма, да се върне `nullptr`.


Г) Напишете програма, която:

Въвежда от потребителя число `vehicleNumber` и след това създава списък от превозни средства с `vehicleNumber`-места.

Въвежда от потребителя точно `vehicleNumber` превозни средства и ги запазва в списъка. Ако потребителят въведе некоректен регистрационен номер (и създаването на Vehicle обект пропадне), програмата ви трябва да може да улови хвърленото изключение(ако използвате такова). 

В такъв случай се извежда съобщение за грешка и потребителят може отново да опита да въведе данните за превозното средство(важи и при използването на булев метод и assert).

Позволява на потребителя да въведе регистрационен номер на превозно средство и отговаря дали то се съдържа в списъка или не.


##  Задача 2
Дефинирайте клас `Time` за работа с часове, минути и секунди. Класът трябва да включва: 

Два конструктора - по подразбиране, който задава стойност 00:00:00 (0 часа, 0 минути и 0 секунди) и конструктор със съответните параметри.

Метод, който увеличава часа с 1 секунда.

Метод `isPartyTime()`, който връща истина, само ако часът е между `22:30` и `01:00`,

Метод, който връща обект от тип `Time`, който съдържа колко време остава до `24:00`.


##  Задача 3
Да се дефинира клас `Item`, който пази информация за име (символен низ с произволна дължина) и цена (реално число) на дадена стока. Да се реализират съответните конструктори, методи за достъпване и промяна на полетата.  

Да се дефинират методи за извеждане на информацията за дадена стока и за проверка на това дали две стоки са еквивалентни (сравнение се извършва по двете полета).
* Допуска се предефиниране на `<<` и `==`.
Реализирайте клас `Shop`, който съдържа динамичен масив от стоки.
Класът има следните методи:

`bool addItem(const Item&)` - добавя стока в магазина и връща истина, ако добавянето е успешно и лъжа в противен случай.
Не се изисква преоразмеряване на масива. 

`bool findItem(const Item&)` - търси дадена стока в магазина.

`void saveToFile(const char* fileName)` - записва информацията за стоките в магазина, подредени по цена в намаляващ ред, в текстов файл с последователен достъп и име fileName.

Конструктор с един параметър от тип fstream, който по подаден файл с последователен достъп (fileName) създава магазин със стоките, които са записани във файла. Разделението между полетата на една стока е <точка>.
##  Задача 4

A) Да се дефинира клас Song, описващ песен с характеристики:

име на изпълнител – символен низ с произволна дължина, записан в динамичната памет;

идентификационен номер на албум, в който ще бъде включена – точно 7 различни символа, съответстващи на цифри и поне 3 главни латински букви;

място в албума – положително число.

място в музикална класация -цяло число от 1 до 100.

Да се дефинират подходящи конструктори, селектори и мутатори и др.. Да се направи проверка за валидност на данните.


Б) Да се дефинира клас MusicAlbum, описващ албум с характеристики:

идентификационен номер на албум – точно 7 различни символа, съответсващи на цифри и поне 3 главни латински букви;

дата и час на издаване – символен низ с дължина точно 16, записан във формат “yyyy-mm-dd hh:mm”. 

масив от песни, участващи в албума. Броят на песните, които могат да участват е <= 20.

Да се дефинират следните член-функции:

Приятелска функция `bool newSong (const Song& ...)`, която проверява дали указаната като аргумент песен е за текущия албум. За сравнение да се използва номерът на албума. Ако условието е изпълнено, песента се записва в масива от песни на албума. Позицията, на която трябва да бъде записана песента се определя от полето място в албума. Ако песента не е за текущия албум, функцията връща лъжа.

`int getSongCount() const`, която връща като резултат броя на песните, които са включени в албума.

Да се дефинира функция `main()`, в която:

да се създаде албум с номер `679ADZ8`, за дата `05-07-2019` в `19:30`;

да се регистрират 2 песни от Поли Генова и Владимир Ампов - Графа, съответно на места 6 и 2;

да се изведе информация за броя на песните, които са в албума.


В) Един албум от песни е с по-висок ранг от друг, ако сумата от местата на песните в музикалната класация, участващи в него е по-малък от сумата на местата на песните в другия албум.

Да се дефинира operator>, който определя дали един албум е с по-висок ранг от друг.

Да се дефинира operator*, който слива два албума като създава и връща нов. Сливането е възможно само ако няма регистрирана песен с един и същ номер в двата албума. Идентификационният номер на новия албум взима първите 4 символа от първия албум и останалите 3 символа от номера на втория албум.

Да се дефинира динамичен масив от музикални албуми. Да се намери поредният номер на песента с най-висок ранг в дефинирания масив.

**Бонус:**

Да се дефинира метод 
`void saveToFile(const char* fileName)` - записва информацията за музикалния албум в двоичен файл с име <fileName.data>

Да се дефинира конструктор `MusicAlbum(const char* fileName)`, който отваря файла с име <fileName.data> и от него възстановява албума