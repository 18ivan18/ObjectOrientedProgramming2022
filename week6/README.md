## Copy конструктор
Конструктор с параметър от тип `const <името-на-класа>&`. Като конструктор има инициализиращ списък. Целта му е да създаде нов обект със стойности на полетата същите като тези на другия подаден. Ако бъде пропуснат ще се генерира автоматично такъв от компилатора, който прави т. нар. `shallow copy`.

### Синтаксис
```c++
class Test {
private:
    int i;
    double d;
public:
    Test(const Test& other): i{other.i}, d{other.d} {}    
};
```
### Кога се извиква
- При създаване на нови обекти от други обекти.
- Неявно при създаване на нов локален обект за дадена функция.
- При връщане на копие на обект от фунцкия
```c++ 
void doSomethingWithTest(Test t) {

}

Test doSomethingElseWithTest(Test t) {
    return t;
}

int main() {
    Test t, t1(t), t2 = t1;
}
```

## Оператор =
Дясно асоциативен оператор за присвояване на стойност на вече съществуващ обект. След извърване на промените по текущия обект, той се връща. Това позволява наслагване на равенство между няколко обекта.
### Синтаксис
```c++
class Test {
private:
    int i;
    double d;
public:
    // стандартна имплементация на operator= 
    Test& operator=(const Test& rhs) {
        if(this != &rhs) {
            i = rhs.i;
            d = rhs.d;
        }
        return *this;
    }
};
```
### Кога се извиква
При присвояване на нова стойност на вече съществуващ обект. 

```c++
int main() {
    Test t, t1(t), t2 = t1;
    t = t1;
    t = t1 = t2; // same as t.operator=(t1.operator=(t2));
}
```

## Shallow vs deep copy
Когато откопираме данните на обекти обикновено искаме всеки обект да разполага сам с паметта на данните си. Това означава да се заделя памет при създаване на обекта и да се изтрива при унищожаването му.

### Shallow copy
```c++
class Test {
private:
    int i;
    double d;
    char* name;
public:
    // shallow copy - the memory for name is now shared between this and other
    Test(const Test& other): i{other.i}, d{other.d}, name{other.name} {} 
    Test& operator=(const Test& rhs) {
        i = rhs.i;
        d = rhs.d;
        name = rhs.name;
        return *this;
    }
};
```

### Deep copy
```c++
class Test {
private:
    int i;
    double d;
    char* name;
public:
    // deep copy - we now manage our own memory
    Test(const Test& other): i{other.i}, d{other.d}, name{new char[strlen(other.name) + 1]} {
        strcpy(name, other.name);
    } 
    Test& operator=(const Test& rhs) {
        if(this != &rhs) {
            i = rhs.i;
            d = rhs.d;
            // here name already exists so we have to manage the memory first
            delete[] name;
            name = new char[strlen(other.name) + 1];
            strcpy(name, other.name);
        }
        return *this;
    }
};
```


# Задачи 
## Задача 1

Напишете клас `Laptop`. Един лаптоп се нуждае от марка и модел (стринг с произволна дължина), цена, размер на екрана (в инчове), процесор (помислете как да представите процесора с нужните му характеристики - тактова честота, брой ядра и размер на КЕШ паметта), РАМ памет и капацитет на батерията. Напишете следните специални методи:

- Конструктор по подразбиране
- Конструктор за копиране
- Конструктор(и) с параметри, данните за един лаптоп
- Оператор за присвояване
- Деструктор
- Оператори <, >, ==, != за сравнение на размерите на екраните на два лаптопа

Напишете подходящи методи за upgrade на процесора и РАМ-а, както и метод за подходящо принтиране на информацията.

## Задача 2

Напишете клас `ToDo`, който описва задача, която трябва да се изпълни. Всяка задача си има id, описание и индикатор за това дали тя е изпълнена или не. Напишете следните специални методи на класа:
- Конструктор по подразбиране
- Конструктор за копиране
- Оператор за присвояване
- Деструктор

Напишете метод за изпълнение на задачата.

## Задача 3

Разширете класа `Complex`, като добавите следните оператор:

- оператор+ (за събиране на две комплексни числа)
- оператор- (за изваждане на две комплексни числа)
- оператор* (за умножение)
- оператор/ (за деление)
- оператор == (за сравнение дали две комплексни числа са равни)
- оператор != (за сравнение дали две комплексни числа не са равни)

## Задача 4

Магьосникът  Маг-О-Кодерски е магьосник в местното за ФМИ заведение BeerOverflow.  Там той изпълнява всяка вечер своя коронен номер - всеки посетител на  BeerOverflow пуска нещо в "магическата кутия" на Маг-О-Кодерски, а в  края на вечерта кутия изхвърля един предмет във въздуха, на случаен  принцип.  

Маг-О-Кодерски  също е и програмист. Той иска да напише програма, в която да въвежда  променливи от целочислен тип, и при извикване на даден метод, "кутията" да му връща  случайна променлива от вече въведените.  

Да се напише клас **MagicalBox** със следните член-данни: 

- Динамичен масив (който да се разширява при необходимост) 

Методи: 

- *insert()* - добавя елемент към кутията 
- *pop()*  - премахва случаен елемент от кутията. Ако кутията е празна, да показва  подходящо съобщение 

Може да дефинирате допълнителни методи и член-данни 